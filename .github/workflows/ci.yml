name: CI

on:
  push:
  pull_request:

env:
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_NOLOGO: true
  dotnet_3_version: '3.1.414'
  dotnet_5_version: '5.0.402'

jobs:

  # Note that vcpkg dependencies takes the majority of the build time.
  # We cache them using GitHub Actions cache, making the scripts below a bit more complex.
  check-format:
    if: github.event_name == 'push' || github.event.pull_request.head.repo.id != github.event.pull_request.base.repo.id
    name: Check format
    runs-on: ubuntu-18.04
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      - name: Setup .NET Core SDK
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: ${{ env.dotnet_5_version }}
      - name: Code formating check
        run: |
          dotnet tool restore
          dotnet jb cleanupcode "csharp" "csharp.test" "csharp.benchmark" --profile="Built-in: Reformat Code" --settings="ParquetSharp.DotSettings" --dotnetcoresdk=${{ env.dotnet_5_version }} --verbosity=WARN

          files=($(git diff --name-only))
          if [ ${#files[@]} -gt 0 ]
          then
            for file in $files; do echo "::error file=$file::Code format check failed"; done
            exit 1
          fi

  # Build everything on all platorms (thus testing the developer workflow).
  # Upload the native shared libraries as artifacts.
  build-native:
    # Do not run this job for pull requests where both branches are from the same repo.
    # Other jobs will be skipped too, as they depend on this one.
    # This prevents duplicate CI runs for our own pull requests, whilst preserving the ability to
    # run the CI for each branch push to a fork, and for each pull request originating from a fork.
    if: github.event_name == 'push' || github.event.pull_request.head.repo.id != github.event.pull_request.base.repo.id
    strategy:
      matrix:
        os: [ubuntu-18.04, macos-latest]
        arch: [x64]
      fail-fast: false
    name: Build native ${{ matrix.arch }} library (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    steps:
    - name: Checkout
      uses: actions/checkout@v2

    # Compute vcpkg triplet and root
    - name: Compute vcpkg triplet and root
      id: vcpkg-info
      run: |
        triplet="${{ matrix.arch }}-"
        case ${{ runner.os }} in
          Linux)
            triplet+="linux"
            ;;
          macOS)
            triplet+="osx"
            ;;
          Windows)
            triplet+="windows-static"
            ;;
        esac
        echo "::set-output name=triplet::$triplet"
        echo "::set-output name=root::$VCPKG_INSTALLATION_ROOT"
      shell: bash

    # Get cmake version, which is used by vcpkg binary caching
    - name: Get cmake version
      id: cmake-info
      run: echo "::set-output name=version::$(cmake --version | head -n1 | awk '{print $3}')"
      shell: bash

    # Check for cached vcpkg dependencies (use these if we can).
    - name: Get cached vcpkg dependencies
      id: get-cached-vcpkg
      uses: actions/cache@v3
      with:
        path: cache/vcpkg
        key: vcpkg-${{ steps.vcpkg-info.outputs.triplet }}-cmake${{ steps.cmake-info.outputs.version }}-${{ hashFiles('vcpkg-configuration.json') }}-${{ hashFiles('vcpkg.json') }}
        restore-keys: |
          vcpkg-${{ steps.vcpkg-info.outputs.triplet }}-cmake${{ steps.cmake-info.outputs.version }}-${{ hashFiles('vcpkg-configuration.json') }}-
          vcpkg-${{ steps.vcpkg-info.outputs.triplet }}-cmake${{ steps.cmake-info.outputs.version }}-
          vcpkg-${{ steps.vcpkg-info.outputs.triplet }}-

    - name: Upload vcpkg cache 1
      uses: actions/upload-artifact@v2
      with:
        name: vcpkg-cache-1
        path: cache/vcpkg/**/*.zip
      